{"name":"Privileged Accessor","tagline":"PrivilegedAccessor is a simple to use Java framework for accessing private methods, attributes, and constructors via reflection. ","body":"**PrivilegedAccessor** is a simple to use Java framework for accessing `private` methods, attributes, and constructors via reflection.\r\n\r\n## Introduction\r\nIn unit-testing you often need to prepare and later inspect the unit-under-test before you can test it. For instance you might need to inject mock-objects in your unit, so your unit-test does not access other units like backend systems. Or you might need to access a private attribute to assert a post-condition of a unit after the test.\r\n\r\nThis could be easily done if Java had no modifiers like private. Accessing private (or protected or package private) methods, attributes, and constructors from outside is forbidden. And you should _never change the modifiers of your production code just for unit-testing purposes_!!!\r\n\r\nFortunately we have reflection to access everything in our classes. Unfortunately reflection is somehow complicated:\r\n\r\n**Example:**\r\nAccessing the private (float) field salary of the object boss of class Manager via reflection:\r\n\r\n    try {\r\n      Field field = Manager.class.getDeclaredField(salary);\r\n      field.setAccessible(true);\r\n      float howMuchMyBossEarns = (float) field.get(boss);\r\n    } catch (NoSuchFieldException e) {\r\n      assert false: \"class 'Manager' has no field 'salary'\";\r\n    } catch (IllegalAccessException e) {\r\n      assert false : \"could not access field 'salary'\";\r\n      return null;\r\n    }\r\n\r\nWith PrivilegedAccessor the same task is much less work:\r\n\r\n    float howMuchMyBossEarns = PA.getValue(boss, \"salary\");\r\n\r\n## Download\r\nYou can download PrivilegedAccessor via [Downloads](https://code.google.com/p/privilegedaccessor/downloads/list) or from maven central using:\r\n\r\n    <dependency>\r\n      <groupId>com.e-movimento.tinytools</groupId>\r\n      <artifactId>privilegedaccessor</artifactId>\r\n      <version>1.2.2</version>\r\n    </dependency>\r\n\r\n## How does it work\r\nPrivilegedAccessor is based on Java reflection and the possibility to change access-rights via \"setAccessible(true)\".\r\nPrivilegedAccessor tries to find the method, attribute, constructor you want to access, sets its accessibility to true and accesses it.\r\n\r\n## Usage\r\nThe usage of PrivilegedAccessor is rather simple. Use the following to access your otherwise unaccessible code:\r\n\r\n * `PA.getValue(Object objectOrClass, String attribute-name)` - to read a private attribute\r\n * `PA.setValue(Object objectOrClass, String attribute-name, Object new-value)` - to change a private attribute\r\n * `PA.instantiate(Class clazz)` - to instantiate a class via its private constructor\r\n * `PA.instantiate(Class clazz, Object... parameters)` - to instantiate a class via a private constructor with parameters\r\n * `PA.invokeMethod(Object objectOrClass, String methodSignature, Object... args)` - to invoke a private method\r\n * `PA.getFieldNames(Object objectOrClass)` - to get all fields of an object or class (including fields of super-classes)\r\n * `PA.getMethodSignatures(Object objectOrClass)` - to get all method signatures of an object or class (including super-classes)\r\n\r\nPA (the convenience short form for PrivilegedAccessor) works with varargs and autoboxing and only throws RuntimeExceptions.\r\n\r\n### Examples\r\n\r\n    PA.getValue(myObject, \"myAttribute\");\r\n    PA.setValue(myObject, \"myAttribute\", 42);\r\n    PA.setValue(myObject, \"myAttribute\", 42).setValue(\"myOtherAttribute\", newValue\");\r\n    PA.instantiate(MyClass.class);\r\n    PA.instantiate(MyClass.class, \"Hello\", \"World\", 42);\r\n    PA.invokeMethod(myObject, \"addInt(int)\", 42);\r\n    PA.invokeMethod(myObject, \"addInteger(java.lang.Integer)\", 42);\r\n    PA.invokeMethod(myObject, \"addIntegers(java.lang.Integer...)\", 42, 43, 44);\r\n    PA.invokeMethod(myObject, \"addIntegerArray(java.lang.Integer[])\", new Integer[] {42, 43, 44});</code>\r\nYou can access methods with all sorts of arguments (primitives, objects, varargs, arrays), just be sure to qualify the arguments correctly.\r\n\r\n## Caveats\r\n * be sure to always use the full method signature for invokeMethod - i.e. including fully qualified parameter classes (e.g. `PA.invokeMethod(myObject, \"setName(java.lang.String)\", \"Tom\");)`\r\n * you can access private inner classes - but you need to add the surrounding object as first argument - e.g. `PA.instantiate(Class.forName(\"mypackage.MyClass$MyInnerClass\"), myObject);`\r\n * you can access final fields, but not change final static fields\r\n\r\n## Compatibility\r\n * PrivilegedAccessor V 1.1 is downward compatible to Java 1.3 (tested), but should work as well with newer releases (tested up to Java 1.7)\r\n * PrivilegedAccessor V 1.2 and onwards is downward compatible to Java 1.5 (tested), but should work as well with newer releases (tested up to Java 1.7)\r\n\r\nPrivilegedAccessor uses a lot of unit tests to check its functionality - if you find a bug or missing feature, please feel free to contact us.\r\n\r\n## Advise\r\n**Do not use PrivilegedAccessor in production code** - since it undermines the information hiding principle.\r\nUse it ONLY for testing or test setup/teardown purposes - e.g. for assigning mock objects, or asserting post-conditions.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}